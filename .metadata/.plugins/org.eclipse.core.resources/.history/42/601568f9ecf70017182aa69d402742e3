import java.util.LinkedList;
import java.util.Queue;

import generator.TreeNode;
public class Solution5 {

	public static void main(String[] args) {
		TreeNode input = new TreeNode(1);
		input.left = new TreeNode(3);
		input.right = new TreeNode(6);
		input.left.left = new TreeNode(2);
		input.left.right = new TreeNode(4);
		input.right.left = new TreeNode(5);
		input.right.right = new TreeNode(0);
		System.out.println(isCousin(input, 3, 0));
	}
	
	public static boolean isCousin(TreeNode root, int a, int b) {
		if (root == null) {
			return false;
		}
		Queue<TreeNode> queC = new LinkedList<TreeNode>();
	    Queue<TreeNode> queP = new LinkedList<TreeNode>();
	    queC.offer(root);
	    queP.offer(root);
	    while(!queC.isEmpty()) {
	    	int size = queC.size();
		    TreeNode curC = null;
		    TreeNode curP = null;
		    boolean findOne = false;
		    TreeNode findParent = null;
		    for(int i = 0 ; i < size ; i++) {
		    	curC = queC.poll();
		        curP = queP.poll();
		        if (curC.key == a || curC.key == b) {
		            if(!findOne) {
		            	findOne = true;
		            	findParent = curP;
		            } else {
		            	if (findParent == curP) {
		            		return false;
		            	} 
		            	return true;
		           }
		       }
		       if (curC.left != null) {
		    	   queC.offer(curC.left);
		           queP.offer(curC);
		       }
		       if (curC.right != null) {
		    	   queC.offer(curC.right);
		    	   queP.offer(curC);
		       }
		   }
	    }
	    return false;
	}
	
	  //Approach: use recursion to check left child and right child of each node with DFS
	  //left right: do smller recursion problem. 
	  //current level: check left node and right node;
	  //return: return whether the node is the parent of a or b.
	  
	  public boolean isCousin(TreeNode root, int a, int b) {
	    if (root == null || a == null || b == null) {
	      return false;
	    }
	    return isCusion(root, a, b, 0, -1, 0);
	  }
	  
	  private boolean isCusin(TreeNode root, int a, int b, int level, int findLevel, int findCounter) {
	    if (root == null) {
	      return true;
	    }
	    if (root.left == a && root.right == b || root.left == b && roob.right == a) {
	      findCounter = 2;
	      return false;
	    } else if (root.left == a || root.right == b || root.left == b || root.right == a) {
	      if (findLevel == -1) {
	        findLevel = level;
	        findCounter ++;
	      } else if (findCounter >= 2){
	          return false;
	      } else {
	        if (findLevel == level) {
	          findCounter ++;
	          return true;
	        } else {
	          findCounter ++;
	          return false;
	        }
	      } 
	    }
	    return isCusin(root.left, a, b, level + 1, findLevel, findCounter) || isCusin(root.left, a, b, level + 1, findLevel,findCounter);
	  }
}
