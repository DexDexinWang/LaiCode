import java.util.PriorityQueue;

public class Solution12 {

	public static void main(String[] args) {
		double[] input = {2.0, -0.1, 4, -2, -1.5};
		System.out.println(largestProduct(input));
	}
	
	/*
	 * Base case: 
	 * dp[0] = 1;
	 * Induction Rule: 
	 * dp[i] = do[j] * dp[j+1] * ... dp[i] where dp[j] is the previous double number that is smaller than 1  
	 */
	public static double largestProduct(double[] array) {
		PriorityQueue<Unit> maxHeap = new PriorityQueue<Unit>();
		double[] dp = new double[array.length + 1];
		dp[0] = 1;
		int start = 0;
		double doubleMax = -1;
		for(int i = 0 ; i < array.length ; i++) {
			if (array[i] > -1 && array[i] < 1) {
				//1. record doubleMax for -1 < i < 1 for all element are in this range.
				doubleMax = Math.max(doubleMax, array[i]);
				//2. put the last production into MaxHeap
				if (dp[i] == 1) {
					double tempMax = Math.abs(dp[i]);
					boolean tempPositive = dp[i] > 0 ? true : false;
					maxHeap.add(new Unit(tempMax, tempPositive, start, i - 1));
				}
				//3. new local range
				start = i;
				dp[i + 1] = 1;
				
			} else {
				dp[i + 1] = dp[i] * array[i];
			}
			
		}
	}
	
	static class Unit implements Comparable<Unit> {
		double max;
		boolean positive;
		int start;
		int end;
		public Unit(double max, boolean positive, int start, int end) {
			this.max = max;
			this.positive = positive;
			this.start = start;
			this.end = end;
		}
		@Override
		public int compareTo(Unit other) {
			if (this.max == other.max) {
				return 0;
			}
			return this.max > other.max ? -1 : 1;
		}
	}
}
