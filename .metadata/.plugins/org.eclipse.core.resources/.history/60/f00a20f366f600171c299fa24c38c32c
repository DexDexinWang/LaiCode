
public class Solution3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}
	  //approach: use priority queue to solve this problem;
	  public int[] merge(int[][] arrayOfArrays) {
	    int rows = arrayOfArrays.length;
	    int cols = arrayOfArrays[0].length;
	    PriorityQueue<Unit> minHeap = new PriorityQueue<Unit>(rows);
	    for (int i = 0; i < rows; i++) { 
	      minHeap.offer(new Unit(i,0,arrayOfArrays[i][0]));
	    }
	    
	    int[] res = new int[rows * cols];
	    for (int i = 0; i < rows * cols ; i++) {
	      Unit cur = minHeap.poll();
	      res[i] = cur.val;
	      if (cur.col < cols - 1) {
	        minHeap.offer(new Unit(cur.row, cur.col + 1, 
	                              arrayOfArrays[cur.row][cur.col + 1]));
	      } 
	    }
	    return res;
	  }
	  
	  class Unit implements Comparable<Unit> {
	    int row;
	    int col;
	    int val;
	    public Unit(int row, int col, int val) {
	      this.row = row;
	      this.col = col;
	      this.val = val;
	    }
	    @Override
	    public int compareTo(Unit other) {
	      if (this.val == other.val) {
	        return 0;
	      }
	      return this.val < other.val ? -1 : 1;
	    }
	  }
}
