import java.util.LinkedList;
import java.util.Queue;

import generator.TreeNode;
public class Solution {

	public static void main(String[] args) {
		TreeNode root = new TreeNode(10);
		root.left = new TreeNode(5);
		root.left.left = new TreeNode(3);
		root.left.right = new TreeNode(4);
		root.right = new TreeNode(2);
		root.right.left = new TreeNode(7);
		root.right.right = new TreeNode(8);
		root.print();
		//same level, same parent
		TreeNode c1 = root.left.left;
		TreeNode c2 = root.left.right;
		System.out.println(isCousins(root,c1,c2));
		//same level, different parent;
		TreeNode c3 = root.left.left;
		TreeNode c4 = root.right.right;
		System.out.println(isCousins(root,c3,c4));
		//differernt level;
		TreeNode c5 = root.left;
		TreeNode c6 = root.right.right;
		System.out.println(isCousins(root,c5, c6));

	}
	
	public static boolean findConsin (TreeNode root, TreeNode c1, TreeNode c2) {
		if (root == null) {
			return false;
		}
		Queue<TreeNode> que = new LinkedList<TreeNode>();
		Queue<TreeNode> queParent = new LinkedList<TreeNode>();
		que.offer(root); 
		queParent.offer(root);
		while (!que.isEmpty()) {
			int size = que.size();
			boolean t1 = false;
			boolean t2 = false;
			for (int i = 0; i < size ; i++) {
				TreeNode curParent = queParent.poll();
				TreeNode cur = que.poll();
				TreeNode temp1 = null;
				TreeNode temp2 = null;
				if (cur == c1) {
					t1 = true;
					temp1	= curParent; 
				}
				if (cur == c2) {
					t2 = true;
					temp2 = curParent;
				}
				if (t1 && t2) {
					if (temp1 == temp2) {
						return false;
					}
				}
				if (cur.left != null) {
					que.offer(cur.left);
					queParent.offer(cur);	
				}
				if (cur.right != null) {
					que.offer(cur.right);	
					queParent.offer(cur);
				}
			}
			if (t1 && t2) {
				return true;
			}
		}
		return false;
	}

	
	
	
	
	
	public static boolean isCousins(TreeNode root,TreeNode nodeA,TreeNode nodeB){
			
			Queue<TreeNodeWapper> queue = new LinkedList<>();
			TreeNodeWapper  wapper = new TreeNodeWapper(null,root,0);
			TreeNodeWapper nodeAWapper = null;
	TreeNodeWapper nodeBWapper = null;
	            queue.offer(wapper);
	            int level = 0;
			while(queue.size()>0){
				level += 1;
				int size = queue.size();
				for(int i = 0;i< size;i++){
					TreeNodeWapper cur = queue.poll();
					if(cur.node.key == nodeA.key){
						nodeAWapper =  cur;
					}
					if(cur.node.key == nodeB.key){
						nodeAWapper =  cur;
					}
					if(nodeAWapper!=null&&nodeBWapper!=null){
						return nodeAWapper.level == nodeBWapper.level  &&nodeAWapper.parent.key!=nodeBWapper.parent.key;
					}
					if(cur.node.left!=null){
						queue.offer(new        TreeNodeWapper(cur.node,cur.node.left,level));
					}
					if(cur.node.right!=null){
		queue.offer(new           TreeNodeWapper(cur.node,cur.node.right,level));
					}
					
				}
	 		}
			return false;
	      }
		
		class TreeNodeWapper{
			TreeNode parent;
			int level;
			TreeNode node;
			
			public TreeNodeWapper(TreeNode p, TreeNode c,int l){
				parent = p;
				node = c;
				level = l;
			}
		}

}
